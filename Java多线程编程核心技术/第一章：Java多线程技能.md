#单任务运行环境
单任务的特点是排队执行，也就是同步，CPU利用率大幅降低。
#多任务运行环境
多任务的特点是切换执行，也就是异步，CPU利用率大幅提升。
多线程是异步的，线程被调用的时机是随机的。

#main
一个进程正在运行时至少会有一个线程在运行，例如由JVM创建的调用main方法的线程。
```
public class Test {
    public static void main(String[] args) {
        System.out.print(Thread.currentThread().getName());
    }
}
```

实现多线程编程的方式主要有两种，一种是继承Thread类，另一种是实现Runnable接口。

线程是一个子任务，CPU以不确定的方式，或者说以随机的时间来调用线程中的run方法。

如果多次调用start方法，会出现异常：
```
Exception in thread "main" java.lang.IllegalThreadStateException
```
线程调用具有随机性，执行start方法的顺序不代表线程启动的顺序。

使用继承Thread类的方法来开发多线程应用程序在设计上是有局限性的，因为Java是单根继承，不支持多继承，所以为了改变这种限制，可以使用实现Runnable接口的方式来实现多线程技术。

Thread.java的8个构造函数：
因为Thread.java类实现了Runnable接口，所以构造函数Thread（Runnable target）不光可以传入Runnable接口的对象，还可以传入Thread的对象，这样做完全可以将一个Thread对象中的run方法交由其他的线程进行调用。


#示例变量与线程安全
自定义线程类中的示例变量针对其他线程可以有共享和不共享之分，这在多个线程之间进行交互时是很重要的一个技术点。


如果有多个线程同时访问，就一定会出现非线程安全问题。
线程非安全主要是指多个线程对同一个对象中的同一个示例进行操作时会出现值被更改、值不同步的情况，进而影响程序的执行流程。
当一个线程想要执行同步方法里面的代码时，线程首先尝试去拿这把锁，如果能拿到这把锁，那么这个线程就可以执行synchronize里面的代码。如果不能拿到这把锁，那么这个线程就会不断地尝试拿这把锁，直到能够拿到为止，而且是有多个线程同时去争抢这把锁。



##isAlive()
测试线程是否处于活动状态，活动状态就是线程已经启动且尚未终止。
在使用isAlive()方法时，如果将线程对象以构造参数的方式传递给Thread对象进行start()启动时，运行的结果和new一个线程对象进行start启动是有差异的。造成这样的差异的原因还是来自于Thread.currentThread()和this的差异。


##sleep()
方法sleep()的作用是在指定的毫秒数内让当前正在执行的线程休眠暂停执行，正在执行的线程是指this.currentThread()返回的线程。


##getId()
获取线程的唯一标识。


##停止线程
停止线程是在多线程开发时候很重要的技术点，掌握此技术可以对线程的停止进行有效的处理。
使用退出标识，使线程正常退出，也就是当run方法完成后线程终止。
Thread.stop()可以终止一个线程，但它是不安全的，而且是已经被废弃的。
Thread.interrupt()不会终止一个正在运行的线程，它仅仅是在当前线程中打了一个停止的标记，并不是真正的停止线程，还需要加入一个判断才能完成线程的终止。

##判断线程是否是停止状态
this.interrupted()测试当前线程是否已经中断，执行后具有将状态标识清除为false的功能。
this.isInterrupted()测试线程是否已经中断，但不清除状态标识。


##Thread.yield()
放弃当前的CPU资源，将其让给其他的任务去占用CPU执行时间，但是放弃的时间不确定，有可能刚刚放弃，马上又获得CPU的时间片。

##优先级
优先级具有继承性：线程A启动线程B，那么线程B的优先级和线程A的优先级是一样的。
优先级具有规则性：CPU尽量将执行资源让给优先级比较高的线程。
高优先级的线程总是大部分先执行完，但不代表高优先级的线程全部先执行完。
当线程优先级的等级差距很大时，谁先执行完和代码的调用顺序无关。
优先级具有随机性：优先级较高的线程不一定每一次都先执行完。

##线程类型
用户线程：
守护线程：当进程中不存在非守护线程，则守护线程自动销毁，随着JVM一同结束工作。垃圾回收线程。

